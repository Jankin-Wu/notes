# RabbitMQ

## MQ（Message Queue）

**作用**

+ 解耦。
+ 冗余〈存储)：有些情况下处理数据的过程会失败，造成数据丢失，可使用消息中间件进行数据持久化；
+ 扩展性:消息中间件解耦了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。
+ 削峰: 在访问量剧增的情况下，程序不会因为突发的超负荷请求而崩溃。
+ 可恢复性: 当系统一部分组件失效时，不会影响到整个系，消息中间件降低了进程间的耦合度，所以即使 个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。
+ 顺序保证: 在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持 定程度上的顺序性。
+ 缓冲: 在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过 个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速 该缓冲层有助于控制和优化数据流经过系统的速度。
+ 异步通信: 在很多时候应用不想也不需要立即处理消息 消息中间件提供了异步处理机制，允许应用把 些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理

核心问题：解耦，异步，削峰。

![消息队列-解耦](http://oss.jankinwu.com/img/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E8%A7%A3%E8%80%A6.jpg)

## 消息队列协议

**1. AMQP（Advance Message Queuing Protocol）**

特点：AMQP 十分可靠且功能强大。当然它及它的实现并不是足够轻量级。

应用场景：当简单的发布－订阅模型不能满足使用要求。

典型实现：RabbitMQ是AMQP消息队列最有名的开源实现。RabbitMQ同时还可以通过插件支持STOMP、MQTT等协议接入。Kafka、RocketMQ 均使用自定义的协议。

**2. MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）**

发布－订阅这一基本功能外，也提供一些其它特性：不同的消息投递保障（delivery guarantee），“至少一次”和“最多一次”。通过存储最后一个被确认接受的消息来实现重连后的消息恢复。

特点：它非常轻量级，并且从设计和实现层面都适合用于不稳定的网络环境中。

应用场景：物联网（IoT）场景中更适合，支持几乎所有语言进行开发，并且浏览器也可通过 WebSocket 来发送和接收 MQTT 消息。

**3. OpenMessage协议**

是近几年由阿里、雅虎和滴滴出行、 Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。
特点：

+ 结构简单
+ 解析速度快
+ 支持事务和持久化设计。

## 消息分发策略

![消息分发策略1](http://oss.jankinwu.com/img/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A51.png)

**轮询分发**

在轮询分发的场景下，交换机并不知道后面消费者的消费能力，就两个消费者一人一个这样轮询
缺点：不同消费者处理任务的时间是不一样的，这样会造成性能浪费

**公平分发**

公平分发的本质就是能者多劳
1. 使用公平分发，必须关闭自动应答ack，然后改成手动应答方式。
2. 每个消费者发送确认消息之前，消息队列不发送下一个消息到消费者，一次只处理一个消息。
限制发送给同一个消费者不得超过1条消息。
3. 消费者增加了channel.basicQos(1)控制同一消息消费次数。

## 安装RabbitMQ

### 使用docker安装

```sh
docker run -dit --name Myrabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management
```



